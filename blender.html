<!DOCTYPE html>
<html>
  <head>
    <title>Image True Blend Demo</title>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      class ImageTrueBlender {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          // 设置固定画布尺寸
          this.canvas.width = 600;
          this.canvas.height = 600;
        }

        async blend(image1Src, image2Src) {
          // 加载两张图片
          const [img1, img2] = await Promise.all([
            this.loadImage(image1Src),
            this.loadImage(image2Src),
          ]);

          // 计算每个图片的Frame尺寸（画布的一半宽度）
          const frameWidth = this.canvas.width / 2;
          const frameHeight = this.canvas.height;

          // 计算图片缩放后的尺寸
          const [img1Scaled, img2Scaled] = [img1, img2].map((img) => {
            const imgRatio = img.width / img.height;
            let scaledWidth, scaledHeight;

            if (imgRatio > frameWidth / frameHeight) {
              // 横向图片，高度适应
              scaledHeight = frameHeight;
              scaledWidth = frameHeight * imgRatio;
            } else {
              // 竖向图片，宽度适应
              scaledWidth = frameWidth;
              scaledHeight = frameWidth / imgRatio;
            }
            return { width: scaledWidth, height: scaledHeight };
          });

          // 计算重叠区域
          const overlapWidth = frameWidth * 0.05; // 重叠宽度 5% - 30%
          const img2StartX = frameWidth - overlapWidth;

          // 创建离屏canvas并绘制缩放后的图片
          const canvas1 = document.createElement("canvas");
          canvas1.width = frameWidth;
          canvas1.height = frameHeight;
          const ctx1 = canvas1.getContext("2d");
          ctx1.drawImage(
            img1,
            0,
            0,
            img1.width,
            img1.height, // source
            0,
            0,
            img1Scaled.width,
            img1Scaled.height // destination
          );

          const canvas2 = document.createElement("canvas");
          canvas2.width = frameWidth;
          canvas2.height = frameHeight;
          const ctx2 = canvas2.getContext("2d");
          ctx2.drawImage(
            img2,
            0,
            0,
            img2.width,
            img2.height, // source
            0,
            0,
            img2Scaled.width,
            img2Scaled.height // destination
          );

          // 绘制非重叠部分
          // 图1的非重叠部分
          this.ctx.drawImage(
            canvas1,
            0,
            0,
            frameWidth - overlapWidth,
            frameHeight, // source
            0,
            0,
            frameWidth - overlapWidth,
            frameHeight // destination
          );

          // 图2的非重叠部分
          this.ctx.drawImage(
            canvas2,
            overlapWidth,
            0,
            frameWidth - overlapWidth,
            frameHeight, // source
            img2StartX + overlapWidth,
            0,
            frameWidth - overlapWidth,
            frameHeight // destination
          );

          // 处理重叠区域
          const overlapRegion = this.ctx.createImageData(
            overlapWidth,
            frameHeight
          );

          // 获取重叠区域的像素数据
          const img1Data = ctx1.getImageData(
            frameWidth - overlapWidth,
            0,
            overlapWidth,
            frameHeight
          );
          const img2Data = ctx2.getImageData(0, 0, overlapWidth, frameHeight);

          // 像素级别的融合
          for (let i = 0; i < overlapRegion.data.length; i += 4) {
            const x = (i / 4) % overlapWidth;
            const blendFactor = x / overlapWidth; // 从左到右的渐变因子

            // 对每个颜色通道进行融合
            for (let j = 0; j < 3; j++) {
              const idx = i + j;
              overlapRegion.data[idx] = Math.round(
                img1Data.data[idx] * (1 - blendFactor) +
                  img2Data.data[idx] * blendFactor
              );
            }
            // Alpha通道
            overlapRegion.data[i + 3] = 255;
          }

          // 将融合后的重叠区域绘制到主画布
          this.ctx.putImageData(overlapRegion, img2StartX, 0);
        }

        loadImage(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
          });
        }
      }

      // 使用示例
      const canvas = document.getElementById("canvas");
      const blender = new ImageTrueBlender(canvas);

      // 替换为实际的图片URL
      blender.blend("./images/1.jpg", "./images/2.jpg").catch(console.error);
    </script>
  </body>
</html>
