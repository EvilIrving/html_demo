<!DOCTYPE html>
<html>
  <head>
    <title>Image True Blend Demo</title>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <!-- 添加滑动条控件 -->
    <div style="margin: 20px">
      <label for="overlapSlider">重叠比例: </label>
      <input
        type="range"
        id="overlapSlider"
        min="0.1"
        max="0.3"
        step="0.02"
        value="0.16"
      />
      <span id="overlapValue">16%</span>
    </div>
    <script>
      class ImageTrueBlender {
        constructor(canvas, image1Src, image2Src) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          // 设置固定画布尺寸
          this.canvas.width = 600;
          this.canvas.height = 600;
          this.image1Src = image1Src;
          this.image2Src = image2Src;
          this.img1 = null;
          this.img2 = null;
          // 初始化时加载图片
          this.initImages();
        }

        async initImages() {
          try {
            [this.img1, this.img2] = await Promise.all([
              this.loadImage(this.image1Src),
              this.loadImage(this.image2Src),
            ]);
            // 初始混合
            const overlapRatio = 0.16;
            this.blend(overlapRatio);
            slider.value = overlapRatio;
            valueDisplay.textContent = `${slider.value}`;
            // 初始化 slider 值, 默认 overlapRatio 是 0.1，对应百分比约为 47%
            // slider.value = ((overlapRatio - 0.01) / 0.19) * 100; // 结果约为47.368
            // valueDisplay.textContent = `${slider.value}%`; // 显示初始百分比
          } catch (error) {
            console.error("图片加载失败:", error);
          }
        }

        // 修改 blend 方法，移除 imageSrc 参数
        blend(overlapRatio = 0.2) {
          if (!this.img1 || !this.img2) {
            console.error("图片尚未加载完成.");
            return;
          }

          // 计算每个图片的Frame尺寸（画布的一半宽度）
          const frameWidth = this.canvas.width / 2;
          const frameHeight = this.canvas.height;

          // 计算图片缩放后的尺寸
          const [img1Scaled, img2Scaled] = [this.img1, this.img2].map((img) => {
            const imgRatio = img.width / img.height;
            let scaledWidth, scaledHeight;

            if (imgRatio > frameWidth / frameHeight) {
              // 横向图片，高度适应
              scaledHeight = frameHeight;
              scaledWidth = frameHeight * imgRatio;
            } else {
              // 竖向图片，宽度适应
              scaledWidth = frameWidth;
              scaledHeight = frameWidth / imgRatio;
            }
            return { width: scaledWidth, height: scaledHeight };
          });

          // 修改重叠计算逻辑
          const scaleRatio = 1 + overlapRatio; // 缩放比例，例如 1.05
          const scaledFrameWidth = frameWidth * scaleRatio; // 缩放后的帧宽度
          const overlapWidth = scaledFrameWidth - frameWidth; // 实际重叠宽度

          // 创建临时画布用于绘制放大后的图片
          const createScaledCanvas = (img, scale) => {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = scaledFrameWidth;
            tempCanvas.height = frameHeight;
            const tempCtx = tempCanvas.getContext("2d");

            const scaledWidth = img.width * scale - img.width;
            const scaledHeight = img.height * scale - img.height;

            tempCtx.drawImage(
              img,
              0,
              0,
              img.width,
              img.height,
              -scaledWidth / 2,
              -scaledHeight / 2,
              img.width * scale + scaledWidth / 2,
              img.height * scale + scaledHeight / 2
            );

            return tempCanvas;
          };

          const canvas1 = createScaledCanvas(this.img1, scaleRatio);
          const canvas2 = createScaledCanvas(this.img2, scaleRatio);

          // 调整绘制位置
          const img2StartX = frameWidth - overlapWidth;

          // 绘制非重叠部分
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.drawImage(
            canvas1,
            0,
            0,
            frameWidth,
            frameHeight,
            0,
            0,
            frameWidth,
            frameHeight
          );

          this.ctx.drawImage(
            canvas2,
            scaledFrameWidth - frameWidth,
            0,
            frameWidth,
            frameHeight,
            frameWidth,
            0,
            frameWidth,
            frameHeight
          );

          // 处理重叠区域
          const overlapRegion = this.ctx.createImageData(
            overlapWidth,
            frameHeight
          );

          // 获取重叠区域的像素数据
          const img1Data = canvas1
            .getContext("2d")
            .getImageData(
              frameWidth - overlapWidth,
              0,
              overlapWidth,
              frameHeight
            );
          const img2Data = canvas2
            .getContext("2d")
            .getImageData(0, 0, overlapWidth, frameHeight);

          // 使用 Smoothstep 函数优化融合过渡
          const smoothstep = (edge0, edge1, x) => {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
          };

          // 优化像素融合算法
          for (let y = 0; y < frameHeight; y++) {
            for (let x = 0; x < overlapWidth; x++) {
              const i = (y * overlapWidth + x) * 4;

              // 使用 smoothstep 计算混合因子
              const blendFactor = smoothstep(0, overlapWidth - 1, x);

              // 优化色彩空间转换和融合
              for (let c = 0; c < 3; c++) {
                const idx = i + c;
                // 使用 gamma 校正进行线性插值
                const color1 = Math.pow(img1Data.data[idx] / 255, 2.2);
                const color2 = Math.pow(img2Data.data[idx] / 255, 2.2);
                const blendedColor =
                  color1 * (1 - blendFactor) + color2 * blendFactor;
                overlapRegion.data[idx] = Math.round(
                  Math.pow(blendedColor, 1 / 2.2) * 255
                );
              }
              overlapRegion.data[i + 3] = 255; // Alpha 通道
            }
          }
          // 将融合后的重叠区域绘制到主画布
          this.ctx.putImageData(overlapRegion, img2StartX, 0);
        }

        loadImage(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
          });
        }
      }

      // 使用示例
      const canvas = document.getElementById("canvas");
      // 图片路径
      const image1Src = "./images/1.jpg";
      const image2Src = "./images/2.jpg";
      const blender = new ImageTrueBlender(canvas, image1Src, image2Src);
      const slider = document.getElementById("overlapSlider");
      const valueDisplay = document.getElementById("overlapValue");

      // 滑动条变化处理函数
      slider.addEventListener("input", function () {
        const value = this.value;
        console.log(value);
        // const overlapRatio = (value / 100) * 0.19 + 0.01; // 将1-100映射到0.01-0.2
        // valueDisplay.textContent = `${value}%`;
        const overlapRatio = parseFloat(value);
        valueDisplay.textContent = `${overlapRatio}`;
        blender.blend(overlapRatio);
      });
    </script>
  </body>
</html>
